import fs from 'fs';
import path from 'path';
import PdfPrinter from 'pdfmake';
import { NextResponse } from 'next/server';

const runicSymbols = ['ᚠ', 'ᚢ', 'ᚦ', 'ᚨ', 'ᚱ', 'ᚲ', 'ᚷ', 'ᚹ', 'ᚺ', 'ᚾ', 'ᛁ', 'ᛃ', 'ᛇ', 'ᛈ', 'ᛉ', 'ᛋ', 'ᛏ', 'ᛒ', 'ᛖ', 'ᛗ', 'ᛚ', 'ᛜ', 'ᛞ', 'ᚼ'];

const generateRandomGrid = () => {
  let grid = [];
  for (let i = 0; i < 5; i++) {
    let row = [];
    for (let j = 0; j < 5; j++) {
      row.push(runicSymbols[Math.floor(Math.random() * runicSymbols.length)]);
    }
    grid.push(row);
  }
  return grid;
};

// const fonts = {
//   NotoSans: {
//     normal: path.join(process.cwd(), 'fonts', 'NotoSans-Regular.ttf'),
//     bold: path.join(process.cwd(), 'fonts', 'NotoSans-Bold.ttf'),
//   },
// };

// const printer = new PdfPrinter(fonts);

export async function POST(req, res) {
    console.log(process.cwd())
  if (req.method !== 'POST') {
    return NextResponse.json({ error: 'Method not allowed' }, { status: 405 });
  }

  const grid = generateRandomGrid();

  const docDefinition = {
    content: [
      { text: 'Runic Symbols Grid', style: 'header' },
      ...grid.map(row => ({ text: row.join(' '), style: 'row' })),
    ],
    styles: {
      header: {
        fontSize: 22,
        bold: true,
        alignment: 'center',
        margin: [0, 20, 0, 20],
      },
      row: {
        fontSize: 16,
        alignment: 'center',
        margin: [0, 10, 0, 10],
      },
    },
    defaultStyle: {
      font: 'NotoSans',
    },
  };

  const pdfDoc = printer.createPdfKitDocument(docDefinition);
  let chunks = [];
  pdfDoc.on('data', (chunk) => chunks.push(chunk));
  pdfDoc.on('end', () => {
    const result = Buffer.concat(chunks);
    const response = NextResponse.next({
      headers: {
        'Content-Type': 'application/pdf',
        'Content-Disposition': 'attachment; filename=runic_grid.pdf',
      },
    });
    res.send(result);
  });
  pdfDoc.end();
}
